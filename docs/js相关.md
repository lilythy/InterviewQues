# 一. JS存储
**1. 基本类型和引用类型如何存储的？堆和栈有什么区别？**
基本类型存储在栈中，引用类型存储在堆中，具体如图：
![](https://pic2.zhimg.com/80/v2-739302e3f0cde0e831d75be8d8ade09a_1440w.png)

![](https://pic2.zhimg.com/80/v2-b9e359bce8bd7424732aa9999d1caf4a_1440w.png)

**2. 栈内存和堆内存的优缺点**
在JS中，基本数据类型变量大小固定，并且操作简单容易，所以把它们放入栈中存储。
引用类型变量大小不固定，所以把它们分配给堆中，让他们申请空间的时候自己确定大小，这样把它们分开存储能够使得程序运行起来占用的内存最小。
栈内存由于它的特点，所以它的系统效率较高。
堆内存需要分配空间和地址，还要把地址存到栈中，所以效率低于栈。

**3. 栈内存和堆内存的垃圾回收**
栈内存中变量一般在它的当前执行环境结束就会被销毁被垃圾回收制回收， 而堆内存中的变量则不会，因为不确定其他的地方是不是还有一些对它的引用。 堆内存中的变量只有在所有对它的引用都结束的时候才会被回收。

# 二.原型链、闭包
**1、new一个实例过程**
用伪代码模拟其内部流程如下：
```javascript
newAnimal('cat') = {
    varobj = {};
    obj.__proto__ = Animal.prototype;
    varresult = Animal.call(obj,"cat");
    returntypeofresult === 'object'? result : obj;
}
```
将上述流程分为 4 个步骤来理解：
（1） 创建一个空对象 obj；
（2） 把 obj 的__proto__ 指向构造函数 Animal 的原型对象 prototype，此时便建立了 obj 对象的原型链：obj->Animal.prototype->Object.prototype->null
（3） 在 obj 对象的执行环境调用 Animal 函数并传递参数 “ cat ” 。
（4） 考察第 3 步的返回值，如果无返回值 或者 返回一个非对象值，则将 obj 作为新对象返回；否则会将 result 作为新对象返回。

**2、闭包**
**变量的作用域**：简单来说，作用域 指程序中定义变量的区域，它决定了当前执行代码对变量的访问权限。分为全局变量和局部变量。
**变量提升：**
先来看看什么是JavaScript中的声明和赋值
```var myname = '极客时间'```
这段代码你可以把它看成是两行代码组成的：
```
var myname    //声明部分
myname = '极客时间'  //赋值部分
```
**所谓的变量提升，是指在JavaScript代码执行过程中，JavaScript引擎把变量的声明部分和函数的声明部分提升到代码开头的“行为”。变量被提升后，会给变量设置默认值，这个默认值就是我们熟悉的undefined。**

**JavaScript代码的执行流程**
**1）编译阶段**
第一部分：变量提升部分的代码。
```
var myname = undefined
function showName() {
    console.log('函数showName被执行');
	```
}
第二部分：执行部分的代码。

```showName()
console.log(myname)
myname = '极客时间'
```
我们可以一行一行来分析上述代码：

- 第1行和第2行，由于这两行代码不是声明操作，所以JavaScript引擎不会做任何处理；
- 第3行，由于这行是经过var声明的，因此JavaScript引擎将在环境对象中创建一个名为myname的属性，并使用undefined对其初始化；
- 第4行，JavaScript引擎发现了一个通过function定义的函数，所以它将函数定义存储到堆(HEAP）中，并在环境对象中创建一个showName的属性，然后将该属性值指向堆中函数的位置（不了解堆也没关系，JavaScript的执行堆和执行栈我会在后续文章中介绍）。 这样就生成了变量环境对象。接下来JavaScript引擎会把声明以外的代码编译为字节码
![](https://camo.githubusercontent.com/0b69270ff3ea627e6752f0c0a4824a5790e087d5/68747470733a2f2f7374617469633030312e6765656b62616e672e6f72672f7265736f757263652f696d6167652f30362f31332f30363535643138656333343761393564666266383433393639613932316131332e706e67)
**2) 执行阶段**
JavaScript引擎开始执行“可执行代码”，按照顺序一行一行地执行。下面我们就来一行一行分析下这个执行过程

- 当执行到showName函数时，JavaScript引擎便开始在变量环境对象中查找该函数，由于变量环境对象中存在该函数的引用，所以JavaScript引擎便开始执行该函数，并输出“函数showName被执行”结果。
- 接下来打印“myname”信息，JavaScript引擎继续在变量环境对象中查找该对象，由于变量环境存在myname变量，并且其值为undefined，所以这时候就输出undefined。
- 接下来执行第3行，把“极客时间”赋给myname变量，赋值后变量环境中的myname属性值改变为“极客时间”

**什么是闭包？闭包为了解决什么问题？为什么闭包不会被回收？**
**闭包概念：**任何持有外部引用的函数，在定义完成之后都是一个闭包。这和在函数内部定义的局部变量不同，局部变量会在函数执行的时候创建、赋值，执行结束之后随着执行上下文销毁。而所持有的外部变量则会因为附着在[[scope]]（作用域链）上而被保留。
**闭包的用途：**它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。

闭包相当于函数的上下文（或者执行环境），编译器通过语法分析，聪明的判断哪些数据需要自动“打包”到函数的上下文里面，通过闭包自动替你管理变量的作用域和生命周期，程序员拿来即用，用完即走，带来丝般顺滑的开发体验。

**闭包主要是为了解决什么问题？**
在比较纯的函数式语言中，还没有对象时，闭包一般代替对象，将各种相关的数据封装起来。考虑到函数式语言是最早采用闭包的，应该是当时遇到同样的问题（封装数据，限制修改，保证数据一致性），有些语言选择了对象，函数式语言选择了闭包吧。此时闭包就成了函数式语言中的封装器，起到对象的作用。

**为什么闭包不会被回收？**
如果闭包函数被外部变量接收，那么这个存在于堆内存中的闭包函数对象就一直存在着（因为它被外部引用着，只要外部作用域不退出，就不会被垃圾回收清除）。那么这个函数对象上的 [[Scope]] 属性（即作用域链）自然就不会被清除，那么作用域链引用的所有层级包含函数的活动对象就不会被清除。

**闭包应用场景**
1） setTimeout
`setTimeout(f1,1000);`
2)函数防抖
`window.onresize = function(){
debounce(fn,1000)
}`
3）回调
4) 用闭包定义能访问私有函数和私有变量的公有函数。
5) 节点循环绑定click事件
```javascript
for (var i = 0; i < infoArr.length; i++) {
    	var item = infoArr[i];
    	document.getElementById(item.id).onfocus = function(){
    		showContent(item.content)
    	}
    }
```




